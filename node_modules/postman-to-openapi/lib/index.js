'use strict'

const { promises: { writeFile, readFile } ,lstatSync,readdir,readdirSync} = require('fs')
const { safeDump } = require('js-yaml')
const { parseMdTable } = require('./md-utils')
const { version } = require('../package.json')
const path = require('path');
async function postmanToOpenApi (input, output, { info = {}, defaultTag = 'default', pathDepth = 0, auth, servers, externalDocs = {} } = {}) {
  
  var postmanJson = []
  if (lstatSync(input).isFile()){
    postmanJson.push(JSON.parse(await readFile(input)))
  }else{
    var files = readdirSync(input);
    for(var i=0;i<files.length;i++){
      postmanJson.push(JSON.parse((await readFile(path.join(input,files[i]))).toString()))
    }
  }
  const paths = {}
  const domains = new Set()
  for (let [i, pjElement] of postmanJson.entries()) {
    const { item: items, variable = [] } = pjElement

    for (let [i, element] of items.entries()) {
      const { item, name, description: tagDesc } = element
      if (item != null) { // is a folder
        const tagged = item.map(e => ({ ...e, tag: name }))
        tags[name] = tagDesc
        items.splice(i, 1, ...tagged)
        element = tagged.shift()
      }
      const {
        request: { url, method, body, description: rawDesc, header },
        name: summary, event: events
      } = element
      const { path, query, protocol, host, port } = scrapeURL(url)
      domains.add(calculateDomains(protocol, host, port))
      const joinedPath = calculatePath(path, pathDepth)
      if (!paths[joinedPath]) paths[joinedPath] = {}
      const { description, paramsMeta } = descriptionParse(rawDesc)
      
      var op = readOption(events)
      var tag = []
      if(op.tags.length > 0){
        tag = op.tags
      }else{
        tag = [defaultTag]
      }
      paths[joinedPath][method.toLowerCase()] = {
        tags: tag,
        summary,
        ...(description ? { description } : {}),
        ...parseBody(body, method,op),
        ...parseParameters(query, header, joinedPath, paramsMeta),
        responses: parseResponse(element.response,op)
      }
    }
  } 
  const openApi = {
    openapi: '3.0.0',
    info:{
      title: "Swagger",
      description: "Swagger",
      version: "1.0.0"
    },
    ...parseExternalDocs([], externalDocs),
    ...parseServers(domains, servers),
    ...parseAuth(postmanJson, auth),
    paths
  }
  const openApiYml = safeDump(openApi, { skipInvalid: true })
  if (output != null) {
    await writeFile(output, openApiYml, 'utf8')
  }
  return openApiYml
}

function compileInfo (postmanJson, optsInfo) {
  const { info: { name, description: desc }, variable = [] } = postmanJson
  const ver = getVarValue(variable, 'version', '1.0.0')
  const {
    title = name, description = desc, version = ver,
    termsOfService, license, contact
  } = optsInfo
  return {
    title,
    description,
    version,
    ...(termsOfService ? { termsOfService } : {}),
    ...parseContact(variable, contact),
    ...parseLicense(variable, license)
  }
}

function parseLicense (variables, optsLicense = {}) {
  const nameVar = getVarValue(variables, 'license.name')
  const urlVar = getVarValue(variables, 'license.url')
  const { name = nameVar, url = urlVar } = optsLicense
  return (name != null) ? { license: { name, ...(url ? { url } : {}) } } : {}
}

function parseContact (variables, optsContact = {}) {
  const nameVar = getVarValue(variables, 'contact.name')
  const urlVar = getVarValue(variables, 'contact.url')
  const emailVar = getVarValue(variables, 'contact.email')
  const { name = nameVar, url = urlVar, email = emailVar } = optsContact
  return [name, url, email].some(e => e != null)
    ? {
      contact: {
        ...(name ? { name } : {}),
        ...(url ? { url } : {}),
        ...(email ? { email } : {})
      }
    }
    : {}
}

function parseExternalDocs (variables, optsExternalDocs) {
  const descriptionVar = getVarValue(variables, 'externalDocs.description')
  const urlVar = getVarValue(variables, 'externalDocs.url')
  const { description = descriptionVar, url = urlVar } = optsExternalDocs
  return (url != null) ? { externalDocs: { url, ...(description ? { description } : {}) } } : {}
}

function recuciveJSON(index,object1,op) {
  var prop = {} 
  for (const [key, value] of Object.entries(object1)) {
    if (typeof value === 'object' && value !== null){
      prop[key] = {}
      prop[key].properties = recuciveJSON(index+"|"+key,value,op);
      prop[key].title = "'"+key+"'";
      prop[key].type = "object";
      // prop[key].example = value
    }else{
      prop[key] = {};
      prop[key].type = typeof value
    }
    if(op.description[index+"|"+key] != null)
      prop[key].description = op.description[index+"|"+key]
    if(op.require[index+"|"+key] != null)
      prop[key].required = [key]
  }
  if (prop.properties != null &&  Object.keys(prop.properties).length === 0 ){
    delete prop.properties
  }
  return prop
}
function parseBody (body = {}, method,op) {
  // Swagger validation return an error if GET has body
  if (['GET', 'DELETE'].includes(method)) return {}
  const { mode, raw, options = { raw: { language: 'json' } } } = body
  let content = {}

  switch (mode) {
    case 'raw': {
      const { raw: { language } } = options
      if (language === 'json') {
        content = {
          'application/json': {
            schema: {
              type: 'object',
              // example: JSON.parse(raw),
              properties: recuciveJSON("|request",JSON.parse(raw),op)
            }
          }
        }
      } else {
        content = {
          'application/json': {
            schema: {
              type: 'string',
              // example: raw
            }
          }
        }
      }
      break
    }
    case 'file':
      content = {
        'text/plain': {}
      }
      break
  }
  return { requestBody: { content } }
}

/* Parse the Postman query and header and transform into OpenApi parameters */
function parseParameters (query = [], header, paths, paramsMeta = {}) {
  // parse Headers
  let parameters = header.reduce(mapParameters('header'), [])
  // parse Query
  parameters = query.reduce(mapParameters('query'), parameters)
  // Path params
  parameters.push(...extractPathParameters(paths, paramsMeta))
  return (parameters.length) ? { parameters } : {}
}

/* Accumulator function for different types of parameters */
function mapParameters (type) {
  return (parameters, { key, description, value }) => {
    const required = /\[required\]/gi.test(description)
    parameters.push({
      name: key,
      in: type,
      schema: { type: inferType(value) },
      ...(required ? { required } : {}),
      ...(description ? { description: description.replace(/ ?\[required\] ?/gi, '') } : {}),
      // ...(value ? { example: value } : {})
    })
    return parameters
  }
}

function extractPathParameters (path, paramsMeta) {
  const matched = path.match(/{\s*[\w-]+\s*}/g) || []
  return matched.map(match => {
    const name = match.slice(1, -1)
    const { type = 'string', description, example } = paramsMeta[name] || {}
    return {
      name,
      in: 'path',
      schema: { type },
      required: true,
      ...(description ? { description } : {}),
      // ...(example ? { example } : {})
    }
  }
  )
}

function getVarValue (variables, name, def = undefined) {
  const variable = variables.find(({ key }) => key === name)
  return variable ? variable.value : def
}

/* calculate the type of a variable based on OPenApi types */
function inferType (value) {
  if (/^\d+$/.test(value)) return 'integer'
  if (/-?\d+\.\d+/.test(value)) return 'number'
  if (/^(true|false)$/.test(value)) return 'boolean'
  return 'string'
}

/* Calculate the global auth based on options and postman definition */
function parseAuth ({ auth }, optAuth) {
  if (optAuth != null) {
    return parseOptsAuth(optAuth)
  }
  return parsePostmanAuth(auth)
}

/* Parse a postman auth definition */
function parsePostmanAuth (postmanAuth = {}) {
  const { type } = postmanAuth
  return (type != null) ? {
    components: {
      securitySchemes: {
        [type + 'Auth']: {
          type: 'http',
          scheme: type
        }
      }
    },
    security: [{
      [type + 'Auth']: []
    }]
  } : {}
}

/* Parse a options global auth */
function parseOptsAuth (optAuth) {
  const securitySchemes = {}
  const security = []
  for (const [secName, secDefinition] of Object.entries(optAuth)) {
    const { type, scheme, ...rest } = secDefinition
    if (type === 'http' && ['bearer', 'basic'].includes(scheme)) {
      securitySchemes[secName] = {
        type: 'http',
        scheme,
        ...rest
      }
      security.push({ [secName]: [] })
    }
  }
  return {
    components: { securitySchemes },
    security
  }
}

/* From the path array compose the real path for OpenApi specs */
function calculatePath (paths = [], pathDepth) {
  paths = paths.slice(pathDepth) // path depth
  // replace repeated '{' and '}' chars
  return '/' + paths.map(path => path.replace(/([{}])\1+/g, '$1'))
    .join('/')
}

function calculateDomains (protocol, hosts, port) {
  return protocol + '://' + hosts.join('.') + (port ? `:${port}` : '')
}

/** Support for collection V2 */
function scrapeURL (url) {
  if (typeof url === 'string' || url instanceof String) {
    if(!url.includes("http://"))
      url="http://" + url
    const objUrl = new URL(url)
    return {
      raw: url,
      path: decodeURIComponent(objUrl.pathname).slice(1).split('/'),
      query: [],
      protocol: objUrl.protocol.slice(0, -1),
      host: decodeURIComponent(objUrl.hostname).split('.'),
      port: objUrl.port
    }
  }
  return url
}

/* Parse domains from operations or options */
function parseServers (domains, serversOpts) {
  let servers
  if (serversOpts != null) {
    servers = serversOpts.map(({ url, description }) => ({ url, description }))
  } else {
    servers = Array.from(domains).map(domain => ({ url: domain }))
  }
  return (servers.length > 0) ? { servers } : {}
}

/* Transform a object of tags in an array of tags */
function parseTags (tagsObj) {
  const tags = Object.entries(tagsObj)
    .map(([name, description]) => ({ name, description }))
  return (tags.length > 0) ? { tags } : {}
}

function descriptionParse (description) {
  if (description == null) return { description }
  const splitDesc = description.split(/# postman-to-openapi/gi)
  if (splitDesc.length === 1) return { description }
  return {
    description: splitDesc[0].trim(),
    paramsMeta: parseMdTable(splitDesc[1])
  }
}

function readOption (events = []) {
  const prerequest = events.filter(event => event.listen === 'prerequest')
  var data = {
    description:{}, 
    require: {},
    tags:[]
  }
  if(prerequest.length == 0)
    return data
  var preExe = prerequest[0].script.exec
  for (let i=0;i < preExe.length;i++){
    if (preExe[i].includes("description") || preExe[i].includes("require") || preExe[i].includes("tags")){
      var sp = preExe[i].split("=")
      sp[0] = sp[0].trim(" ")
      var keySp = sp[0].split(".")
      var st = "" 
      for(var j=1;j<keySp.length; j++){
        st += "|"+keySp[j]
      }
      if(preExe[i].includes("description")){
        data.description[st] = sp[1]
      }else if (preExe[i].includes("require")){
        data.require[st] = Boolean(sp[1])
      }else if (preExe[i].includes("tags")){
        data.tags = sp[1].split(",")
      } 
    }
  }
  return data
}
function parseResponse (response = [],op) {
  if (response.length == 0) {
    return {}
  }
  var status = {}
  for (let [i, element] of response.entries()){
    var body = JSON.parse(element.body)
    var description = ""
    if(element.originalRequest.body != null && element.originalRequest.body.raw != ""){
      var bodyRaw = JSON.parse(element.originalRequest.body.raw)
      description = bodyRaw["description"]
    }
    status[element.code] = {
      description: description,
      content:{
          "application/json":{
            schema: {
              type: 'object',
              // example: body,
              properties: recuciveJSON("|response",body,op)
            }
          }
      }
    }
  }
  return status
}

postmanToOpenApi.version = version

module.exports = postmanToOpenApi
