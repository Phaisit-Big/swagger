'use strict'

const {
  promises: {
    writeFile,
    readFile
  },
  lstatSync,
  readdir,
  readdirSync
} = require('fs')
const {
  safeDump
} = require('js-yaml')
const {
  parseMdTable
} = require('./md-utils')
const {
  version
} = require('../package.json')
const path = require('path');
async function postmanToOpenApi(input, output, {
  info = {},
  defaultTag = 'default',
  pathDepth = 0,
  auth,
  servers,
  externalDocs = {}
} = {}) {

  var postmanJson = []
  if (lstatSync(input).isFile()) {
    postmanJson.push(JSON.parse(await readFile(input)))
  } else {
    var files = readdirSync(input);
    for (var i = 0; i < files.length; i++) {
      postmanJson.push(JSON.parse((await readFile(path.join(input, files[i]))).toString()))
    }
  }
  const paths = {}
  const domains = new Set()
  for (let [i, pjElement] of postmanJson.entries()) {
    const {
      item: items,
      variable = []
    } = pjElement

    for (let [i, element] of items.entries()) {
      const {
        item,
        name,
        description: tagDesc
      } = element
      if (item != null) { // is a folder
        const tagged = item.map(e => ({
          ...e,
          tag: name
        }))
        tags[name] = tagDesc
        items.splice(i, 1, ...tagged)
        element = tagged.shift()
      }
      const {
        request: {
          url,
          method,
          body,
          description: rawDesc,
          header
        },
        response: response,
        name: summary
      } = element
      const {
        path,
        query,
        protocol,
        host,
        port
      } = scrapeURL(url)
      domains.add(calculateDomains(protocol, host, port))
      const joinedPath = calculatePath(path, pathDepth)
      if (!paths[joinedPath]) paths[joinedPath] = {}
      const {
        description,
        paramsMeta
      } = descriptionParse(rawDesc)

      var op = readOption(response)
      var tag = []
      if (op.tags.length > 0) {
        tag = op.tags
      } else {
        tag = [defaultTag]
      }
      paths[joinedPath][method.toLowerCase()] = {
        tags: tag,
        summary,
        ...(description ? {
          description
        } : {}),
        ...parseBody(body, method, op),
        ...parseParameters(query, header, joinedPath, paramsMeta, op),
        responses: parseResponse(element.response, op)
      }
    }
  }
  const openApi = {
    openapi: '3.0.0',
    info: {
      title: "Swagger",
      description: "Swagger",
      version: "1.0.0"
    },
    ...parseExternalDocs([], externalDocs),
    ...parseServers(domains, servers),
    ...parseAuth(postmanJson, auth),
    paths
  }
  const openApiYml = safeDump(openApi, {
    skipInvalid: true
  })
  if (output != null) {
    await writeFile(output, openApiYml, 'utf8')
  }
  return openApiYml
}

function compileInfo(postmanJson, optsInfo) {
  const {
    info: {
      name,
      description: desc
    },
    variable = []
  } = postmanJson
  const ver = getVarValue(variable, 'version', '1.0.0')
  const {
    title = name, description = desc, version = ver,
      termsOfService, license, contact
  } = optsInfo
  return {
    title,
    description,
    version,
    ...(termsOfService ? {
      termsOfService
    } : {}),
    ...parseContact(variable, contact),
    ...parseLicense(variable, license)
  }
}

function parseLicense(variables, optsLicense = {}) {
  const nameVar = getVarValue(variables, 'license.name')
  const urlVar = getVarValue(variables, 'license.url')
  const {
    name = nameVar, url = urlVar
  } = optsLicense
  return (name != null) ? {
    license: {
      name,
      ...(url ? {
        url
      } : {})
    }
  } : {}
}

function parseContact(variables, optsContact = {}) {
  const nameVar = getVarValue(variables, 'contact.name')
  const urlVar = getVarValue(variables, 'contact.url')
  const emailVar = getVarValue(variables, 'contact.email')
  const {
    name = nameVar, url = urlVar, email = emailVar
  } = optsContact
  return [name, url, email].some(e => e != null) ?
    {
      contact: {
        ...(name ? {
          name
        } : {}),
        ...(url ? {
          url
        } : {}),
        ...(email ? {
          email
        } : {})
      }
    } :
    {}
}

function parseExternalDocs(variables, optsExternalDocs) {
  const descriptionVar = getVarValue(variables, 'externalDocs.description')
  const urlVar = getVarValue(variables, 'externalDocs.url')
  const {
    description = descriptionVar, url = urlVar
  } = optsExternalDocs
  return (url != null) ? {
    externalDocs: {
      url,
      ...(description ? {
        description
      } : {})
    }
  } : {}
}

function recuciveJSON(object1, op) {
  var prop = {}
  for (const [key, value] of Object.entries(object1)) {
    if (typeof value === 'object' && value !== null) {
      var newOp = {
        description: null,
        required: null
      }
      if (op.description != null && key in op.description) {
        newOp.description = op.description[key]
      }
      if (op.required != null && key in op.required) {
        newOp.required = op.required[key]
      }
      prop[key] = {}
      prop[key].properties = recuciveJSON(value, newOp);
      prop[key].title = "'" + key + "'";
      prop[key].type = "object";
      prop[key].example = value
    } else {
      prop[key] = {};
      prop[key].type = typeof value
    }
    if (op.description != null && key in op.description && "$val" in op.description[key]){
      if (typeof op.description[key]["$val"] === 'string') {
        prop[key].description = op.description[key]["$val"]
      }else if (Array.isArray(op.description[key]["$val"])){
        prop[key].description = op.description[key]["$val"].join("\n")
      }
    }
    if(op.required != null){
      for (const [key, value] of Object.entries(op.required)) {
        var required = []
        if("$val" in value)
          required.push(key)
      }
      prop.required = required
    }
  }
  if (prop.properties != null && Object.keys(prop.properties).length === 0) {
    delete prop.properties
  }
  return prop
}

function parseBody(body = {}, method, op) {
  // Swagger validation return an error if GET has body
  if (['GET', 'DELETE'].includes(method)) return {}
  const {
    mode,
    raw,
    options = {
      raw: {
        language: 'json'
      }
    }
  } = body
  let content = {}

  switch (mode) {
    case 'raw': {
      var required = []
      for (const [key, value] of Object.entries(op.required.request)) {
        if("$val" in value && value["$val"])
          required.push(key)
      }
      content = {
        'application/json': {
          schema: {
            type: 'object',
            example: JSON.parse(raw),
            properties: recuciveJSON(JSON.parse(raw), {
              description: op.description.request,
              required: op.required.request
            }),
            required: required
          }
        }
      }
      break
    }
    case 'file':
      content = {
        'text/plain': {}
      }
      break
  }
  return {
    requestBody: {
      content
    }
  }
}

/* Parse the Postman query and header and transform into OpenApi parameters */
function parseParameters(query = [], header, paths, paramsMeta = {},op) {
  // parse Headers
  let parameters = header.reduce(mapParameters('header'), [])
  // parse Query
  parameters = query.reduce(mapParameters('query'), parameters)
  // Path params
  parameters.push(...extractPathParameters(paths, paramsMeta,{
    description: op.description.path,
    required: op.required.path
  }))
  return (parameters.length) ? {
    parameters
  } : {}
}

/* Accumulator function for different types of parameters */
function mapParameters(type) {
  return (parameters, {
    key,
    description,
    value
  }) => {
    const required = /\[required\]/gi.test(description)
    parameters.push({
      name: key,
      in: type,
      schema: {
        type: inferType(value)
      },
      ...(required ? {
        required
      } : {}),
      ...(description ? {
        description: description.replace(/ ?\[required\] ?/gi, '')
      } : {}),
      ...(value ? {
        example: value
      } : {})
    })
    return parameters
  }
}

function extractPathParameters(path, paramsMeta,op) {
  const matched = path.match(/{\s*[\w-]+\s*}/g) || []
  return matched.map(match => {
    const name = match.slice(1, -1)
    const {
      type = 'string', example
    } = paramsMeta[name] || {}
    var description = ""
    var required = false
    if(op.description != null && name in op.description){
      if (typeof op.description[name]["$val"] === 'string') {
        description = op.description[name]["$val"]
      }else if (Array.isArray(op.description[name]["$val"])){
        description = op.description[name]["$val"].join("\n")
      }
    }
    if(op.required != null && name in op.required){
      required = op.required[name]["$val"]
    }
    return {
      name,
      in: 'path',
      schema: {
        type
      },
      required: required,
      ...(description ? {
        description
      } : {}),
      ...(example ? {
        example
      } : {})
    }
  })
}

function getVarValue(variables, name, def = undefined) {
  const variable = variables.find(({
    key
  }) => key === name)
  return variable ? variable.value : def
}

/* calculate the type of a variable based on OPenApi types */
function inferType(value) {
  if (/^\d+$/.test(value)) return 'integer'
  if (/-?\d+\.\d+/.test(value)) return 'number'
  if (/^(true|false)$/.test(value)) return 'boolean'
  return 'string'
}

/* Calculate the global auth based on options and postman definition */
function parseAuth({
  auth
}, optAuth) {
  if (optAuth != null) {
    return parseOptsAuth(optAuth)
  }
  return parsePostmanAuth(auth)
}

/* Parse a postman auth definition */
function parsePostmanAuth(postmanAuth = {}) {
  const {
    type
  } = postmanAuth
  return (type != null) ? {
    components: {
      securitySchemes: {
        [type + 'Auth']: {
          type: 'http',
          scheme: type
        }
      }
    },
    security: [{
      [type + 'Auth']: []
    }]
  } : {}
}

/* Parse a options global auth */
function parseOptsAuth(optAuth) {
  const securitySchemes = {}
  const security = []
  for (const [secName, secDefinition] of Object.entries(optAuth)) {
    const {
      type,
      scheme,
      ...rest
    } = secDefinition
    if (type === 'http' && ['bearer', 'basic'].includes(scheme)) {
      securitySchemes[secName] = {
        type: 'http',
        scheme,
        ...rest
      }
      security.push({
        [secName]: []
      })
    }
  }
  return {
    components: {
      securitySchemes
    },
    security
  }
}

/* From the path array compose the real path for OpenApi specs */
function calculatePath(paths = [], pathDepth) {
  paths = paths.slice(pathDepth) // path depth
  // replace repeated '{' and '}' chars
  return '/' + paths.map(path => path.replace(/([{}])\1+/g, '$1'))
    .join('/')
}

function calculateDomains(protocol, hosts, port) {
  return protocol + '://' + hosts.join('.') + (port ? `:${port}` : '')
}

/** Support for collection V2 */
function scrapeURL(url) {
  if (typeof url === 'string' || url instanceof String) {
    if (!url.includes("http://"))
      url = "http://" + url
    const objUrl = new URL(url)
    return {
      raw: url,
      path: decodeURIComponent(objUrl.pathname).slice(1).split('/'),
      query: [],
      protocol: objUrl.protocol.slice(0, -1),
      host: decodeURIComponent(objUrl.hostname).split('.'),
      port: objUrl.port
    }
  }
  return url
}

/* Parse domains from operations or options */
function parseServers(domains, serversOpts) {
  let servers
  if (serversOpts != null) {
    servers = serversOpts.map(({
      url,
      description
    }) => ({
      url,
      description
    }))
  } else {
    servers = Array.from(domains).map(domain => ({
      url: domain
    }))
  }
  return (servers.length > 0) ? {
    servers
  } : {}
}

/* Transform a object of tags in an array of tags */
function parseTags(tagsObj) {
  const tags = Object.entries(tagsObj)
    .map(([name, description]) => ({
      name,
      description
    }))
  return (tags.length > 0) ? {
    tags
  } : {}
}

function descriptionParse(description) {
  if (description == null) return {
    description
  }
  const splitDesc = description.split(/# postman-to-openapi/gi)
  if (splitDesc.length === 1) return {
    description
  }
  return {
    description: splitDesc[0].trim(),
    paramsMeta: parseMdTable(splitDesc[1])
  }
}

function readOption(responses) {
  const schemaBody = responses.filter(response => response.name.toUpperCase() === 'SCHEMA')
  if (schemaBody.length == 0)
    return {}
  var body = schemaBody[0].body
  return JSON.parse(body)
}

function parseResponse(response = [], op) {
  if (response.length == 0) {
    return {}
  }
  var status = {}
  for (let [i, element] of response.entries()) {
    if (element.name.toUpperCase() != "SCHEMA") {
      var body = JSON.parse(element.body)
      var description = ""
      if (element.originalRequest.body != null && element.originalRequest.body.raw != "") {
        var bodyRaw = JSON.parse(element.originalRequest.body.raw)
        description = bodyRaw["description"]
      }
      var required = []
      if("response" in op.required){
        for (const [key, value] of Object.entries(op.required.response)) {
          if("$val" in value && value["$val"])
            required.push(key)
        }
      }
      status[element.code] = {
        description: description,
        content: {
          "application/json": {
            schema: {
              type: 'object',
              example: body,
              properties: recuciveJSON(JSON.parse(element.body), {
                description: op.description.response,
                required: op.required.response
              }),
              required:required
            }
          }
        }
      }
    }
  }

  return status
}

postmanToOpenApi.version = version

module.exports = postmanToOpenApi
